# -*- coding: utf-8 -*-
"""практика.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DmpRY4yAYnXeEhLgcSU1bTZKYBUnZ6vz
"""

# установим библиотеку tensorflow (через нее используем keras)
!pip install tensorflow

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from tensorflow import keras
from keras.models import Sequential
from keras.layers import LSTM, Dense, Dropout
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from sklearn.metrics import r2_score
from sklearn.model_selection import train_test_split

# Загрузка данных
dat = pd.read_csv('USD_RUB.csv')

dat

dat.info()

# Преобразование столбца 'Date' в формат datetime
dat['Date'] = pd.to_datetime(dat['Date'])
# Установка 'Date' в качестве индекса
dat.set_index('Date', inplace=True)

# Линейный график цен
plt.figure(figsize=(14, 7))
plt.plot(dat['Price'], label='Цена', color='blue')
plt.title('Динамика цен на валюту')
plt.xlabel('Дата')
plt.ylabel('Цена')
plt.legend()
plt.grid()
plt.show()

# Гистограмма цен
plt.figure(figsize=(14, 7))
plt.hist(dat['Price'], bins=30, color='skyblue', edgecolor='black')
plt.title('Распределение цен')
plt.xlabel('Цена')
plt.ylabel('Частота')
plt.grid()
plt.show()

# Коробчатая диаграмма для цен
plt.figure(figsize=(14, 7))
sns.boxplot(x=dat['Price'], color='lightgreen')
plt.title('Коробчатая диаграмма цен')
plt.xlabel('Цена')
plt.grid()
plt.show()

# Диаграмма рассеяния: Цена vs. Открытие
plt.figure(figsize=(14, 7))
plt.scatter(dat['Open'], dat['Price'], alpha=0.5, color='orange')
plt.title('Диаграмма рассеяния: Открытие vs. Цена')
plt.xlabel('Цена открытия')
plt.ylabel('Цена')
plt.grid()
plt.show()

# Изменение цен во времени
plt.figure(figsize=(14, 7))
plt.plot(dat['Change %'], label='Изменение %', color='red')
plt.title('Изменение цен в процентах во времени')
plt.xlabel('Дата')
plt.ylabel('Изменение %')
plt.legend()
plt.grid()
plt.show()

# Подготовка данных
dat['Change %'] = dat['Change %'].str.replace('%', '').astype(float) / 100
a = dat[['Price', 'Open', 'High', 'Low',]].values
b = dat['Change %'].values

# Нормализация данных
scaler = MinMaxScaler()
features_scaled = scaler.fit_transform(a)

# Разделение на признаки и целевую переменную
X = features_scaled
y = b

# Разделение на обучающую и тестовую выборки
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Создание нейронной сети
model = Sequential()
model.add(Dense(64, activation='relu', input_shape=(X_train.shape[1],)))  # Входной слой
model.add(Dense(32, activation='relu'))  # Скрытый слой
model.add(Dense(1, activation='linear'))  # Выходной слой

# Компиляция модели
model.compile(optimizer='adam', loss='mean_squared_error')

from keras.callbacks import EarlyStopping
# Обучение модели с использованием ранней остановки
stopping = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)
history = model.fit(X_train, y_train, validation_split=0.2, epochs=100, batch_size=32, callbacks=[stopping])

!pip install scikeras
!pip install sklearn
from scikeras.wrappers import KerasRegressor

from sklearn.model_selection import GridSearchCV

# Обёртка модели Keras
model = KerasRegressor(build_fn=model, verbose=0)

# Определение параметров для поиска по сетке
param_grid = {
    'neurons': [32, 64, 128],  # Количество нейронов в первом слое
    'optimizer': ['adam', 'rmsprop'],  # Оптимизаторы
    'batch_size': [16, 32],  # Размеры батчей
    'epochs': [50, 100], # Количество эпох
    'fit_callbacks': [[stopping]]
}

# Upgrade XGBoost
!pip install --upgrade xgboost

# Or downgrade Scikit-learn
!pip install scikit-learn==1.0.2

# Создаём GridSearchCV
grid = GridSearchCV(estimator=model, param_grid=param_grid, cv=3, n_jobs=-1)
# Обучаем с кросс-валидацией и ранней остановкой
grid_result = grid.fit(X_train, y_train)

# Обучение модели с использованием перекрёстной проверки
grid_result = grid.fit(X_train, y_train, validation_split=0.2, callbacks=[stopping])
# Вывод лучших параметров и результатов
print(f"Лучшие параметры: {grid_result.best_params_}")
print(f"Лучший результат: {grid_result.best_score_}")

# Прогнозирование
predictions = model.predict(X_test)

# Оценка модели
loss = model.evaluate(X_test, y_test)
loss

# Вычисление MSE
mse = np.sqrt(mean_squared_error(y_test, predictions))
mse

# Расчет R²
r2 = r2_score(y_test, predictions)
r2

# Проверка 10 предсказаний
for i in range(10):
    print(f"Истинное значение: {y_test[i]:.4f}, Предсказанное значение: {predictions[i][0]:.4f}")

import matplotlib.pyplot as plt
# Визуализация потерь
plt.figure(figsize=(14, 7))
plt.plot(history.history['loss'], label='Обучение')
plt.plot(history.history['val_loss'], label='Валидация')
plt.title('Потери модели')
plt.xlabel('Эпохи')
plt.ylabel('Потери')
plt.legend()
plt.grid()
plt.show()

# Анализ ошибок
errors = y_test - predictions.flatten()

# Визуализация ошибок
plt.figure(figsize=(14, 7))
plt.plot(errors, label='Ошибки предсказания', color='orange', alpha=0.6)
plt.axhline(0, color='black', lw=2, ls='--')
plt.title('Ошибки предсказания')
plt.xlabel('Номер образца')
plt.ylabel('Ошибка (Истинное - Предсказанное)')
plt.legend()
plt.grid()
plt.show()